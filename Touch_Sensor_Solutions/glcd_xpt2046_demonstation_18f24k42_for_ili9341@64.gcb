
'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program is a simple GLCD demonstration of the ILI9341 GLCD capabilities.
'''It is a nice graphical LCD, suitable for a lot of various projects.
'''This program draws lines, boxes, circles and prints strings and numbers.
'''The GLCD is connected to the microprocessor as shown in the hardware section of this code.
''':
'''This has been tested using the hardware SPI option.
''':
''':
'''@author  EvanV
'''@licence GPL
'''@version 1.0
'''@date    29/03/19
'''********************************************************************************

'Chip Settings
#CHIP 18f24k42, 64
#CONFIG MCLRE=On
#OPTION Explicit
#INCLUDE <glcd.h>
#INCLUDE <xpt2046.h>

#DEFINE GLCD_TYPE GLCD_TYPE_ILI9341

'Generated by PIC PPS Tool for Great Cow Basic
'PPS Tool version: 0.0.5.25
'PinManager data: Not available (3)
'Generated for 18F24K42
'
'Template comment at the start of the config file
'
#STARTUP InitPPS, 85
#DEFINE PPSToolPart 18F24K42

Sub InitPPS

    'This has been added to turn off PPS SPI when in SPI software mode
    #IFDEF ILI9341_hardwarespi
        'Module: SPI1
        'RC4 > SDI1
        SPI1SDIPPS = 0x0014
        'SDO1 > RC5
        RC5PPS = 0x001F
        'SCK1 > RC3
        RC3PPS = 0x001E
        'RC3 > SCK1 (bi-directional)
        SPI1SCKPPS = 0x0013
    #ENDIF

End Sub
'Template comment at the end of the config file


'Pin mappings for ILI9341
#DEFINE GLCD_DC portb.0
#DEFINE GLCD_CS portb.2
#DEFINE GLCD_RESET portb.1

'This is a PPS chip, so, needs to make the PPS match these assignments
'The following example is commented out intentionally
'#define GLCD_DI portc.4
#DEFINE GLCD_DO portc.5
#DEFINE GLCD_SCK portc.3

#DEFINE ILI9341_hardwarespi

'For the K42 type SPI MODULE ONLY hardware SPI only
'You can specify an SPI baud rate - the baud rate is dependent on the chip frequency!
'If you get nothing, you have exceeded the SPI modules capabilites, so, slow down the BAUD RATE or use the SPI_BAUD_RATE_REGISTER constant, shown below.

'The default SPI_BAUD_RATE is 1/4th of the clock frequency in khz. Khz is used to allow for fine adjustment
'The following example is commented out intentionally
'#define SPI_BAUD_RATE 32000

'or, use an explicit constant as show below
'The following example is commented out intentionally
'#define SPI_BAUD_RATE_REGISTER 9

'Optionally, you can define the HWSPIMode by using #define HWSPIMode masterfast where #define HWSPIMode is masterslow|master|masterfast
'This will overwrite the default in the GLCD SPI library.  This is so users do not have to change the library.
'the default is "master"
'The following example can be commented out if you want to use the default value
'#define HWSPIMode master



'******************************************************************************************************
'Setup the XPT2046

'Typical calibration range for Hardware SPI when using XPT2046
'for 320 * 240 screeen... may be different for others
#DEFINE XPT2046XMIN   15
#DEFINE XPT2046YMIN   14
#DEFINE XPT2046XMAX   110
#DEFINE XPT2046YMAX   113
#DEFINE XPT2046_ReadSamples 15

'Typical Calibration range for Software SPI when using XPT2046
'    #define XPT2046XMIN   30
'    #define XPT2046YMIN   25
'    #define XPT2046XMAX   210
'    #define XPT2046YMAX   225


' Data in | MISO
#DEFINE XPT2046_DI       portc.4
' Data out | MOSI
#DEFINE XPT2046_DO       portc.5
' Clock Line
#DEFINE XPT2046_SCK      portc.3
' Chip select line
#DEFINE XPT2046_CS       portc.1
#DEFINE XPT2046_IRQ      portc.0
' remove/comment out if you want to use software SPI - must use same method as GLCD
#DEFINE XPT2046_HardwareSPI
'Optionally, you can define the HWSPIMode by using #define HWSPIMode masterfast where #define HWSPIMode is masterslow|master|masterfast
'This will overwrite the default in the XPT2046 library.  This is so users do not have to change the library.
'the default is "masterfast"
'The following example is commented out intentionally
'#define HWSPIMode masterfast



'Set the initial calibration - shown here to show the method.
'If you rotate the screen then you will have to call the method to reset these parameters.
SetCalibation_XPT2046 ( XPT2046XMIN, XPT2046XMAX, XPT2046YMIN, XPT2046YMAX, GLCD_WIDTH, GLCD_HEIGHT  )

'******************************************************************************************************
'******************************************************************************************************
'Main program
GLCDRotate Portrait_Rev
GLCDCLS TFT_NAVY
SetCalibation_XPT2046 ( XPT2046XMIN, XPT2046XMAX, XPT2046YMIN, XPT2046YMAX, GLCD_WIDTH, GLCD_HEIGHT )
ScreenLayout

Dim Xconverge, Yconverge As Integer
Dim convergeCounter As Byte
Do

    Xconverge = 0
    Yconverge = 0
    convergeCounter = 1

    FilledBox Current_GLCD_WIDTH, 0, Current_GLCD_WIDTH-10, 10, TFT_RED
    'always wait for touch event
    Wait While isTouched_XPT2046
    FilledBox Current_GLCD_WIDTH, 0, Current_GLCD_WIDTH-10, 10, TFT_YELLOW
    Do
        Repeat 5
            'get the values -
            GetXY_XPT2046( XTouchPoint_XPT2046, YTouchPoint_XPT2046 )
        End Repeat
        'test for settling by testing for convergance
        If ABS( ( Xconverge - XTouchPoint_XPT2046 ) ) > 1  OR  ABS( ( Yconverge - YTouchPoint_XPT2046 ) ) > 1  Then
            Xconverge = XTouchPoint_XPT2046
            Yconverge = YTouchPoint_XPT2046
            convergeCounter++
        Else
            'converged
            Exit Do
        End If
    Loop
    'Flip the data to handle for the screen rotation
    YTouchPoint_XPT2046 = Current_GLCD_HEIGHT - YTouchPoint_XPT2046
    FilledBox Current_GLCD_WIDTH, 0, Current_GLCD_WIDTH-10, 10, TFT_GREEN
    If XTouchPoint_XPT2046 > Current_GLCD_WIDTH-59 AND YTouchPoint_XPT2046 > Current_GLCD_HEIGHT-20  Then
        If XTouchPoint_XPT2046 < Current_GLCD_WIDTH AND  YTouchPoint_XPT2046 < Current_GLCD_HEIGHT Then
            'clear
            ScreenLayout
        End If
    Else

        FilledCircle XTouchPoint_XPT2046, YTouchPoint_XPT2046, 3, TFT_LIGHTGREY

        'Show the raw data
        GLCDPrint ( 24, 56, Pad(Str(XTouchPoint_XPT2046raw),3 ) )
        GLCDPrint ( 24, 72, Pad(Str(YTouchPoint_XPT2046raw),3 ) )
        GLCDPrint ( 24, 90, Pad(Str(convergeCounter ) ,3 ) )

        'Automatically adjust the values to min and max
        'Not needed in a real program use SetCalibation_XPT2046( XPT2046_Xmin, XPT2046_Xmax, XPT2046_Ymin, XPT2046_Ymax )
        If XTouchPoint_XPT2046raw < XPT2046_Xmin Then XPT2046_Xmin = XTouchPoint_XPT2046raw
        If YTouchPoint_XPT2046raw < XPT2046_Ymin Then XPT2046_Ymin = YTouchPoint_XPT2046raw
        If XTouchPoint_XPT2046raw > XPT2046_Xmax Then XPT2046_Xmax = XTouchPoint_XPT2046raw
        If YTouchPoint_XPT2046raw  > XPT2046_Ymax Then XPT2046_Ymax = YTouchPoint_XPT2046raw

        'show the values
        GLCDPrint ( 102, 56, Pad(Str(XPT2046_Xmin),3 ) )
        GLCDPrint ( 102, 72, Pad(Str(XPT2046_Ymin),3 ) )
        GLCDPrint ( 162, 56, Pad(Str(XPT2046_Xmax),3 ) )
        GLCDPrint ( 162, 72, Pad(Str(XPT2046_Ymax),3 ) )

        GLCDPrint ( 24, 230, Pad(Str(XTouchPoint_XPT2046),5 ))
        GLCDPrint ( 24, 246, Pad(Str(YTouchPoint_XPT2046),5 ))

        'do not hammer the touch
        Wait 20 ms

    End If

Loop


Sub ScreenLayout

    #DEFINE GLCD_OLED_FONT
    GLCDfntDefaultSize = 2
    GLCDFontWidth = 5
    'Layout the screen
    GLCDCLS
    GLCDPrint ( 2, 3, "XPT2046 demonstration 2019")
    Line 0, 34, Current_GLCD_WIDTH, 34
    Line 0, 128, Current_GLCD_WIDTH, 128
    Line 0, 220, Current_GLCD_WIDTH, 220
    GLCDPrint ( 2, 25, "Dynamic Calibration")
    GLCDPrint ( 22, 40, "Raw    Min   Max")
    GLCDPrint ( 2, 56, "X:")
    GLCDPrint ( 2, 72, "Y:")
    GLCDPrint ( 2, 90, "C:")

    GLCDPrint ( 2, 122, "Current Calibration")
    GLCDPrint ( 2, 146, "X:")
    GLCDPrint ( 2, 162, "Y:")
    GLCDPrint ( 102, 146, Pad(Str(XPT2046_Xmin),3 ) )
    GLCDPrint ( 102, 162, Pad(Str(XPT2046_Ymin),3 ) )
    GLCDPrint ( 162, 146, Pad(Str(XPT2046_Xmax),3 ) )
    GLCDPrint ( 162, 162, Pad(Str(XPT2046_Ymax),3 ) )
    GLCDPrint ( 2, 214, "Scaled")
    GLCDPrint ( 2, 230, "X:")
    GLCDPrint ( 2, 246, "Y:")

    GLCDPrint ( 120, 214, "GLCD Size")
    GLCDPrint ( 120, 230, "X:" + Str( Current_GLCD_WIDTH ) )
    GLCDPrint ( 120, 246, "Y:" + Str( Current_GLCD_HEIGHT ) )


    GLCDfntDefaultSize = 1
    GLCDPrint ( 2, Current_GLCD_HEIGHT-17, "v0.9c")
    GLCDfntDefaultSize = 2

    FilledBox Current_GLCD_WIDTH, 0, Current_GLCD_WIDTH-10, 10, TFT_RED

    Dim oldGLCDBackground As Word
    oldGLCDBackground = GLCDBackground
    GLCDBackground = TFT_WHITE
    GLCDPrint ( Current_GLCD_WIDTH-58, Current_GLCD_HEIGHT-18, "Clear", TFT_BLACK )
    GLCDBackground = oldGLCDBackground

    ' ------ Version Control - optional
    #INCLUDE "GCBVersionNumber.cnt"
    'Include the GCBVersionNumber.cnt to increment versionString and create the build time string called GCBBuildTimeStr.
    ' versionString a string is created automatically.
    ' GCBBuildTimeStr is a string that is also created automatically.
    ' use "GCBVersionNumber.cnt" as this will create a local copy of the versionString tracker.
    ' if you use <GCBVersionNumber.cnt> this is a system wide versionString tracker.

    Dim versionString As String * 40
    versionString = "Build: "+GCBBuildStr
    versionString = versionString + "@"+GCBBuildTimeStr
    GLCDfntDefaultSize = 1
    GLCDPrint ( 2, Current_GLCD_HEIGHT-10, versionString)
    GLCDfntDefaultSize = 2
    ' ------ End of Version Control - optional
End Sub
