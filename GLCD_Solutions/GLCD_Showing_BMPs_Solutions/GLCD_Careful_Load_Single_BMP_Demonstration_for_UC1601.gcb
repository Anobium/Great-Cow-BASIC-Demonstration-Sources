'''A demonstration program for GCGB and GCB.
'''--------------------------------------------------------------------------------------------------------------------------------
'''This program is a simple GLCD demonstration of the UC1601 GLCD capabilities.
'''This program updates the GLCD with a BMP then updates the GLCD with a bar graph.
'''@author  EvanV
'''@licence GPL
'''@version 1.0
'''@date    27.08.2019
'''********************************************************************************

; ----- Configuration
    #chip 16f18446, 32
    #option explicit


; ----- Define GLCD Hardware settings
    #include <glcd.h>

    #define GLCD_TYPE GLCD_TYPE_UC1601
    #define GLCD_I2C_Address      0x70                   'I2C address
    #define GLCD_RESET            portc.0                'Hard Reset pin connection
    #define GLCD_PROTECTOVERRUN
    #define GLCD_OLED_FONT

    'Generated by PIC PPS Tool for Great Cow Basic
    'PPS Tool version: 0.0.5.20
    'PinManager data: v1.65.2
    'Generated for 16F18446
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85
    #define PPSToolPart 16F18446

    Sub InitPPS

            'Module: MSSP1
            RB7PPS = 0x0013    'SCL1 > RB7
            SSP1CLKPPS = 0x000F    'RB7 > SCL1 (bi-directional)
            RB5PPS = 0x0014    'SDA1 > RB5
            SSP1DATPPS = 0x000D    'RB5 > SDA1 (bi-directional)

    End Sub
    'Template comment at the end of the config file

; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS if required for your specific device.
    #define HI2C_BAUD_RATE 100
    #define HI2C_DATA  PORTB.5
    #define HI2C_CLOCK PORTB.7
    'I2C pins need to be input for SSP module when used on this type of Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in
    HI2CMode Master


  ; ----- Main body of program commences here.  This is reusable code.

    GLCDCLS

    #include "gcb.bmp"
    ' Table Name. This is required.  Just means you can reuse the BMP load code but referring your BMP to TableData
    #define TableData GCB

  ; ----- Variables
    ' These must be WORDs as this a large table.    These are required!!
    dim TableReadPosition as word
    dim TableLen as word
    Dim OBJWIDTH, OBJHEIGHT, GLCDXPOS, GLCDYPOS, OLDGLCDXPOS, WHOLEYBYTES, HCOUNT, GLCDY, WIDTHCOUNT, WBYTE, OPTMISEGLCDDRAW, ONPAGEBOUNDARY, GLCDX, CURRPAGE, MAXHEIGHT, l_CurrCharRow as Byte




    ' These must be WORDs as this a large table.
    dim TableReadPosition, TableLen as word

    ' either 0 or 1.  Needs to match the background pixel state.
    OptmiseGLCDDraw  = 0

    ' Start of code
    TableReadPosition = 1
    ReadTable TableData, TableReadPosition, objwidth: TableReadPosition++
    ReadTable TableData, TableReadPosition, objHeight: TableReadPosition++

    ' sart draw at the upper left corner is set with GLCDXPos, GLCDYPos
    GLCDXPos = 0
    GLCDYPos = 0

    oldGLCDXPos = GLCDXPos
    'BMP file has the first piece of data at byte number 3.
    TableReadPosition = 3

    ' Number of whole bytes within Y Axis.  This is integer maths!
    WholeYBytes = objHeight /  8

    ' If GLCDYPos as a memory page boundary.  Used to fast write the byte
    onPageBoundary = ( GLCDYPos % 8 ) = 0

      'Do we have more than 8 rows of data - if so WholeYBytes <> 0
      if WholeYBytes <> 0 then

          ' counter to number of whole bytes
          for hCount = 0 to (WholeYBytes - 1)

                GLCDY = GLCDYPos+hCount
                ' increment thru bytes horizontally
                for widthCount = 0 to (objwidth - 1)
                    ' get the next byte
                    ReadTable TableData, TableReadPosition, wByte: TableReadPosition++
                    ' if the incoming byte is the same as the background, dont draw
                    if wByte <> OptmiseGLCDDraw then
                       ' So,  we have to draw this byte
                       ' If a a page boundary  this is a faster draw routine
                       if onPageBoundary = true then
                          ' just write the data out, no need to read whats there.
                          GLCDX = GLCDXPos+widthCount
                          Cursor_Position_UC1601 ( GLCDX , GLCDY )
                          Write_Data_UC1601 wByte

                       else
                          ' slow draw using X Y position and interate throught the bits
                          For l_CurrCharRow = 0 to 7
                                    If wByte.0 = 0 Then
                                              PSet GLCDXPos+widthCount, l_CurrCharRow + GLCDYPos, GLCDBackground
                                    Else
                                              PSet GLCDXPos+widthCount, l_CurrCharRow + GLCDYPos, GLCDForeground
                                    End If
                                    Rotate wByte Right
                          Next
                       end if

                     end if

                next widthCount

                GLCDXPos =  oldGLCDXPos
                GLCDYPos = GLCDYPos + 8

          next hCount

      end if

      ' calculate the remaining bits to be dealt with in the BMP
      maxHeight = objHeight % 8

      'writes and remaining bits, if any
      if maxHeight <> 0 then

        for widthCount = 0 to objwidth - 1
          ReadTable TableData, TableReadPosition, wByte: TableReadPosition++
              ' slow draw using X Y position and interate throught the bits
              For l_CurrCharRow = 0 to maxHeight-1
                        If wByte.0 = 0 Then
                                  PSet GLCDXPos+widthCount, ( l_CurrCharRow + GLCDYPos ), GLCDBackground
                        Else
                                  PSet GLCDXPos+widthCount, ( l_CurrCharRow + GLCDYPos ), GLCDForeground
                        End If
                        Rotate wByte Right
              Next
        next
      end if


      'Now update the GLCD

      dim mypos as byte
      box 9,9, 55, 13

      do
          for mypos = 10 to 44
            filledbox mypos, 10, mypos+10, 12, 1
            wait 120 ms
            filledbox  mypos, 10, mypos+10, 12, 0
            wait 120 ms
          next
          for mypos = 44 to 10
            filledbox mypos, 10, mypos+10, 12, 1
            wait 120 ms
            filledbox  mypos, 10, mypos+10, 12, 0
            wait 120 ms
          next


      loop
      END
